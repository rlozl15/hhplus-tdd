백엔드 코스 1주차: TDD 
# 동시성 제어 문제 분석 보고서
## 1. 문제 정의
포인트를 충전하거나 사용하는 과정에서 같은 사용자가 동시에 여러 요청을 하는 경우, 
서로 다른 스레드가 동일한 사용자 데이터(UserPoint)를 읽고 수정하는 과정에서 Lost Update 문제가 발생할 수 있다.

### 예상 시나리오 (충전)
1. 사용자 A의 현재 포인트: `10,000` 포인트
2. 스레드 1에서 포인트 충전을 위해 저장된 UserPoint를 조회 (`10,000` 포인트)
3. 스레드 2에서 마찬가지로 저장된 UserPoint를 동시에 조회 (`10,000` 포인트)
4. 스레드 1에서 `1,000` 포인트 충전 계산 (`11,000` 포인트)
5. 스레드 2에서 `2,000` 포인트 충전 계산 (`12,000` 포인트)
6. 스레드 1과 스레드 2가 동시에 결과 저장
   - 스레드 1: `11,000` 포인트 저장
   - 스레드 2: `12,000` 포인트 저장
7. 최종적으로 `12,000` 포인트가 저장
    - `13,000` 포인트가 되어야 하지만 **Lost Update**로 인해 데이터 누락이 발생

## 2. 적용한 동시성 제어 방식
### Synchronized block
- Java의 `synchronized` 블록을 활용하여 사용자별로 동기화를 적용
- 동일 사용자 요청: 순차적으로 처리를 통한 Lost Update 방지
- 서로 다른 사용자 요청: 비동기적으로 처리
### 구현 방법
1. `ConcurrentHashMap<Long, Object>`을 사용하여 사용자별 Lock 객체를 관리
2. `computeIfAbsent`로 사용자별 락 객체 생성 혹은 재사용
3. `synchronized(lockObject)` 블록 안에서 포인트 충전 및 사용 로직 수행

```java
private final ConcurrentHashMap<Long, Object> userLocks = new ConcurrentHashMap<>();

public UserPoint charge(long userId, long amount) {
    Object lock = userLocks.computeIfAbsent(userId, k -> new Object());
    synchronized (lock) {
        // 포인트 충전 혹은 사용 로직
    }
}
```

### 선택 이유
- 단일 서버 환경이기에 분산 락 등이 불필요
- JVM 레벨에서 보장되는 `synchronized`를 사용
- 구현이 단순하여 유지보수가 상대적으로 쉬움

## 3. 통합 테스트 결과
### 테스트 환경
  - 단일 서버
  - 동시 요청 스레트 100개 기준
### 테스트 결과
  - 데이터 일관성 유지 확인
  - 충전 및 사용 내역도 정상적으로 기록
### 성능 비교 (락 유무에 따른 처리 시간 차이)

| 구분   | 충전 요청 | 사용 요청 |
|------|-------|-------|
| 락 없음 | 약 1초  | 약 6초  |
| 락 있음 | 약 39초 | 약 47초 |

## 4. 추가 고려사항
### 성능 축면
  - 동기화로 인한 처리 속도 저하
  - 요청량이 늘어날수록 그에 비례해 시스템 응답 속도가 저하될 우려가 있음
### 확장성 측면
  - `synchronized` 방식은 단일 서버 환경에서만 유효함

## 5. 결론
- 단일 서버 환경과 간단한 구현이라는 조건으로 사용자별 락을 통한 `synchronized` 동기화 방식 적용
- 포인트 데이터의 일관성을 보장하며, Lost Update 문제 해결
- 성능 저하 문제와 분산 환경 적용의 한계가 있음으로 추가적인 개선 필요